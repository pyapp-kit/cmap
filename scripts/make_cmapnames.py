#!/usr/bin/env python3
"""Generate a `Literal[...]` type annotation for named colormaps."""

import sys
from argparse import ArgumentParser
from difflib import unified_diff
from pathlib import Path

import cmap

scripts_dir = Path(__file__).resolve().parent
module_dir = scripts_dir.parent.joinpath("src", "cmap")
data_dir = module_dir.joinpath("data")
out_file = module_dir.joinpath("_colormapname.pyi")

SCRIPT_TEMPLATE = '''
"""Type annotation for literal colormap names.

Auto-generated by make_cmapnames.py : DO NOT EDIT.
"""

from typing import Literal, TypeAlias

ColormapName: TypeAlias = Literal[
{}]
'''.lstrip()


def get_cmap_names():
    """Get the names of colormap items."""
    visited = set()
    catalog = cmap.Catalog()
    catalog.disable_warn_on_alias()
    for item in catalog.values():
        for name in [item.qualified_name, item.name]:
            for rev in ["", "_r"]:
                full = name + rev
                if full in visited:
                    continue
                yield full
                visited.add(full)


def generate_script():
    """Produce the expected script."""
    names_iter = get_cmap_names()
    names_fmt = "".join(" " * 4 + f'"{n}",\n' for n in names_iter)

    return SCRIPT_TEMPLATE.format(names_fmt)


def main(args=None):
    """Main function for this script."""
    parser = ArgumentParser()
    parser.add_argument(
        "--check",
        action="store_true",
        help=("do not write results, just print the diff and exit code 1 if non-empty"),
    )
    parser.add_argument(
        "--exit-code",
        action="store_true",
        help=("write the results, but return exit code 1 if there are changes to make"),
    )

    parsed = parser.parse_args(args)

    new = generate_script()
    old = out_file.read_text() if out_file.is_file() else ""

    if new == old:
        return 0

    if parsed.check:
        sys.stdout.writelines(
            unified_diff(
                old.splitlines(keepends=True),
                new.splitlines(keepends=True),
                fromfile="existing",
                tofile="new",
            )
        )
        return 1

    out_file.write_text(new)
    if parsed.exit_code:
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
